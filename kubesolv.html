<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KubeSolv | Kubernetes AI Ops</title>
    <meta
      name="description"
      content="KubeSolv is an AI-powered Kubernetes operations platform for real-time detection, notification, and auto-healing."
    />
    <style>
      :root {
        --bg: #f4f8ff;
        --panel: rgba(255, 255, 255, 0.84);
        --line: rgba(94, 132, 214, 0.2);
        --text: #162246;
        --muted: #556696;
        --brand: #3f6eff;
        --cyan: #16c6d3;
        --violet: #7f6cff;
        --ok: #1ebd7a;
        --warn: #f1b846;
        --bad: #ee5f72;
        --shadow: 0 18px 44px rgba(35, 62, 132, 0.12);
      }

      * {
        box-sizing: border-box;
      }

      html {
        scroll-behavior: smooth;
      }

      body {
        margin: 0;
        font-family: Inter, Poppins, 'Segoe UI', system-ui, sans-serif;
        color: var(--text);
        background:
          radial-gradient(circle at 7% 0%, rgba(89, 129, 255, 0.16), transparent 32%),
          radial-gradient(circle at 92% 2%, rgba(22, 198, 211, 0.14), transparent 36%),
          var(--bg);
      }

      .bg-canvas {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 0;
      }

      .shell {
        width: min(1180px, calc(100% - 2rem));
        margin: 0 auto;
        position: relative;
        z-index: 1;
      }

      .topbar {
        margin-top: 1rem;
        padding: 0.78rem 1rem;
        border: 1px solid var(--line);
        border-radius: 1rem;
        background: var(--panel);
        backdrop-filter: blur(8px);
        box-shadow: var(--shadow);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      .brand {
        text-decoration: none;
        color: var(--text);
        display: inline-flex;
        align-items: center;
        gap: 0.55rem;
        font-weight: 800;
        letter-spacing: 0.02em;
      }

      .brand svg {
        width: 1.65rem;
        height: 1.65rem;
      }

      .topnav {
        display: flex;
        gap: 0.45rem;
        flex-wrap: wrap;
      }

      .topnav a {
        text-decoration: none;
        color: var(--muted);
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 0.42rem 0.74rem;
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        font-weight: 700;
        transition: 0.2s ease;
      }

      .topnav a:hover {
        color: var(--text);
        border-color: rgba(63, 110, 255, 0.42);
      }

      .section {
        padding-top: 4rem;
      }

      .reveal {
        opacity: 0;
        transform: translateY(16px);
        transition: opacity 0.7s ease, transform 0.7s ease;
      }

      .reveal.in {
        opacity: 1;
        transform: translateY(0);
      }

      .hero {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
      }

      .panel {
        border: 1px solid var(--line);
        border-radius: 1.35rem;
        background: var(--panel);
        box-shadow: var(--shadow);
      }

      .hero-copy {
        padding: clamp(1rem, 3vw, 2.2rem);
      }

      .eyebrow {
        margin: 0;
        color: var(--brand);
        font-size: 0.73rem;
        letter-spacing: 0.14em;
        text-transform: uppercase;
        font-weight: 800;
      }

      h1,
      h2,
      h3 {
        margin: 0;
        line-height: 1.12;
      }

      h1 {
        font-size: clamp(2rem, 4.9vw, 3.8rem);
        margin-top: 0.8rem;
      }

      h2 {
        font-size: clamp(1.55rem, 3.7vw, 2.65rem);
      }

      .hero-sub {
        margin: 0.9rem 0 0;
        color: var(--muted);
        font-size: clamp(1rem, 2vw, 1.15rem);
        max-width: 34ch;
      }

      .signal-strip {
        margin-top: 0.95rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .signal-token {
        font-weight: 800;
        letter-spacing: 0.02em;
        border: 1px solid rgba(63, 110, 255, 0.2);
        background: rgba(63, 110, 255, 0.08);
        color: #1f47cc;
        border-radius: 999px;
        padding: 0.3rem 0.6rem;
        transition: 0.35s ease;
      }

      .signal-token.alert {
        color: #fff;
        background: linear-gradient(135deg, #3968ff, #1ebd7a);
        border-color: transparent;
        box-shadow: 0 0 0 6px rgba(63, 110, 255, 0.1);
      }

      .hero-actions {
        margin-top: 1.4rem;
        display: flex;
        gap: 0.65rem;
        flex-wrap: wrap;
      }

      .btn {
        border: 1px solid var(--line);
        border-radius: 0.85rem;
        padding: 0.72rem 1rem;
        text-decoration: none;
        font: inherit;
        font-weight: 700;
        letter-spacing: 0.02em;
        cursor: pointer;
        transition: transform 0.2s ease;
      }

      .btn:hover {
        transform: translateY(-1px);
      }

      .btn-primary {
        color: #fff;
        border-color: transparent;
        background: linear-gradient(135deg, var(--brand), #4374ff);
      }

      .btn-secondary {
        color: var(--text);
        background: rgba(255, 255, 255, 0.7);
      }

      .hero-map-wrap {
        padding: 1rem;
        min-height: 22rem;
        position: relative;
        overflow: hidden;
      }

      #hero-map {
        width: 100%;
        height: 100%;
        display: block;
      }

      .cluster-tooltip {
        position: absolute;
        pointer-events: none;
        z-index: 5;
        min-width: 170px;
        max-width: 210px;
        border: 1px solid rgba(91, 131, 230, 0.45);
        border-radius: 0.7rem;
        background: rgba(15, 24, 47, 0.9);
        color: #dce8ff;
        padding: 0.5rem 0.6rem;
        font-size: 0.75rem;
        line-height: 1.5;
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 0.18s ease, transform 0.18s ease;
      }

      .cluster-tooltip.show {
        opacity: 1;
        transform: translateY(0);
      }

      .cluster-tooltip strong {
        display: block;
        font-size: 0.82rem;
        margin-bottom: 0.22rem;
        color: #7bc8ff;
      }

      .lead {
        margin: 0.78rem 0 0;
        color: var(--muted);
      }

      .feature-grid {
        margin-top: 1rem;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 0.9rem;
      }

      .feature {
        padding: 1rem;
        transition: transform 0.2s ease, border-color 0.2s ease;
      }

      .feature:hover {
        transform: translateY(-4px);
        border-color: rgba(63, 110, 255, 0.45);
      }

      .feature .k-icon {
        width: 2rem;
        height: 2rem;
        border-radius: 0.58rem;
        background: rgba(63, 110, 255, 0.12);
        color: var(--brand);
        font-weight: 800;
        display: grid;
        place-items: center;
      }

      .feature p {
        margin: 0.45rem 0 0;
        color: var(--muted);
        font-size: 0.91rem;
      }

      .how-grid {
        margin-top: 1rem;
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 0.8rem;
      }

      .how-step {
        padding: 1rem;
      }

      .how-step b {
        width: 1.48rem;
        height: 1.48rem;
        border-radius: 999px;
        display: inline-grid;
        place-items: center;
        color: var(--brand);
        background: rgba(63, 110, 255, 0.13);
        font-size: 0.8rem;
      }

      .how-step p {
        margin: 0.62rem 0 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .demo-grid {
        margin-top: 1rem;
        display: grid;
        grid-template-columns: 1.06fr 0.94fr;
        gap: 1rem;
      }

      .demo-card {
        padding: 1rem;
      }

      #ops-map,
      #mini-map {
        width: 100%;
        display: block;
        border: 1px solid var(--line);
        border-radius: 0.95rem;
        background: rgba(236, 244, 255, 0.72);
      }

      #ops-map {
        height: 19rem;
      }

      #mini-map {
        height: 6.8rem;
        margin-top: 0.72rem;
      }

      .state-legend {
        display: flex;
        gap: 1rem;
        color: var(--muted);
        font-size: 0.82rem;
        margin-top: 0.58rem;
      }

      .state-legend i {
        width: 0.62rem;
        height: 0.62rem;
        border-radius: 50%;
        display: inline-block;
        margin-right: 0.34rem;
      }

      .timeline {
        margin: 0.8rem 0 0;
        padding: 0;
        list-style: none;
        display: grid;
        gap: 0.56rem;
      }

      .timeline li {
        border: 1px solid var(--line);
        border-radius: 0.8rem;
        background: rgba(255, 255, 255, 0.74);
        color: #2d3f6d;
        padding: 0.58rem 0.68rem;
        font-size: 0.85rem;
        display: flex;
        gap: 0.5rem;
        align-items: flex-start;
      }

      .t-dot {
        width: 0.56rem;
        height: 0.56rem;
        border-radius: 50%;
        margin-top: 0.26rem;
        flex-shrink: 0;
      }

      .metrics {
        margin-top: 0.75rem;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.7rem;
      }

      .metric {
        padding: 0.72rem;
      }

      .metric p {
        margin: 0;
        color: var(--muted);
        font-size: 0.7rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .metric canvas {
        width: 100%;
        height: 3rem;
        display: block;
        margin-top: 0.35rem;
      }

      .chat {
        margin-top: 0.75rem;
        border: 1px solid var(--line);
        border-radius: 0.9rem;
        padding: 0.78rem;
        background: rgba(255, 255, 255, 0.72);
      }

      .bubble {
        border-radius: 0.75rem;
        padding: 0.56rem 0.62rem;
        max-width: 84%;
        font-size: 0.88rem;
      }

      .bubble.ask {
        margin-left: auto;
        background: #e8efff;
      }

      .bubble.answer {
        margin-top: 0.45rem;
        background: #e3fbff;
        color: #244a69;
      }

      .cta {
        margin-top: 1rem;
        padding: 1.3rem;
        background: linear-gradient(118deg, rgba(111, 146, 255, 0.17), rgba(20, 192, 210, 0.16));
      }

      .cta p {
        margin: 0.54rem 0 0;
        color: var(--muted);
      }

      footer {
        margin: 3rem 0 1.4rem;
        border-top: 1px solid var(--line);
        padding-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 0.7rem;
        color: var(--muted);
        font-size: 0.84rem;
      }

      footer a {
        color: var(--muted);
        text-decoration: none;
        margin-left: 0.9rem;
      }

      footer a:hover {
        color: var(--text);
      }

      .modal {
        position: fixed;
        inset: 0;
        z-index: 30;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        background: rgba(12, 18, 38, 0.52);
        backdrop-filter: blur(4px);
      }

      .modal.open {
        display: flex;
      }

      .modal-card {
        width: min(460px, 100%);
        border: 1px solid var(--line);
        border-radius: 1rem;
        background: #fff;
        box-shadow: var(--shadow);
        padding: 1rem;
      }

      .modal-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.7rem;
      }

      .close {
        border: 0;
        background: transparent;
        font-size: 1.3rem;
        color: var(--muted);
        cursor: pointer;
      }

      .field {
        margin-top: 0.7rem;
      }

      .field label {
        font-size: 0.86rem;
        font-weight: 600;
      }

      .field input {
        margin-top: 0.28rem;
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 0.72rem;
        padding: 0.66rem 0.72rem;
        font: inherit;
      }

      .status {
        margin-top: 0.54rem;
        min-height: 1.2rem;
        font-size: 0.85rem;
        color: #118f56;
      }

      @media (max-width: 1040px) {
        .hero,
        .demo-grid {
          grid-template-columns: 1fr;
        }

        .feature-grid {
          grid-template-columns: 1fr 1fr;
        }

        .how-grid {
          grid-template-columns: 1fr 1fr;
        }
      }

      @media (max-width: 700px) {
        .shell {
          width: min(1180px, calc(100% - 1rem));
        }

        .section {
          padding-top: 2.7rem;
        }

        .topbar {
          flex-direction: column;
          align-items: stretch;
        }

        .feature-grid,
        .how-grid,
        .metrics {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="bg-canvas" class="bg-canvas" aria-hidden="true"></canvas>

    <div class="shell">
      <header class="topbar">
        <a href="index.html" class="brand" aria-label="Back to portfolio">
          <svg viewBox="0 0 64 64" aria-hidden="true">
            <path d="M32 4 57 18v28L32 60 7 46V18z" fill="#326CE5" />
            <path d="M32 16c8.8 0 16 7.2 16 16s-7.2 16-16 16-16-7.2-16-16 7.2-16 16-16z" fill="#fff" />
            <circle cx="32" cy="32" r="6" fill="#326CE5" />
          </svg>
          KubeSolv
        </a>
        <nav class="topnav" aria-label="KubeSolv navigation">
          <a href="#features">Features</a>
          <a href="#how">How</a>
          <a href="#demo">Demo</a>
          <a href="#cta">Contact</a>
        </nav>
      </header>

      <main>
        <section class="section hero reveal" id="hero">
          <article class="panel hero-copy">
            <p class="eyebrow">AI-Powered Kubernetes Operations</p>
            <h1>Your Cluster Can Now Talk Back</h1>
            <p class="hero-sub">Answers questions about your Kubernetes cluster in real-time.</p>

            <div class="signal-strip" id="signal-strip" aria-live="polite">
              <span class="signal-token" data-signal="detect">Detects.</span>
              <span class="signal-token" data-signal="notify">Notifies.</span>
              <span class="signal-token" data-signal="heal">Auto-Heals.</span>
            </div>

            <div class="hero-actions">
              <button class="btn btn-primary" type="button" id="open-modal">Want to Know More?</button>
              <a class="btn btn-secondary" href="#demo">Watch Demo</a>
            </div>
          </article>

          <aside class="panel hero-map-wrap">
            <canvas id="hero-map" aria-label="Interactive Kubernetes cluster map"></canvas>
            <div id="cluster-tooltip" class="cluster-tooltip"></div>
          </aside>
        </section>

        <section class="section reveal" id="features">
          <h2>Built for Kubernetes AI Ops</h2>
          <p class="lead">A focused product experience for cluster observability, incident response, and AI-assisted remediation.</p>

          <div class="feature-grid">
            <article class="panel feature"><div class="k-icon">1</div><h3>Real-time Cluster Intelligence</h3><p>Live workload visibility across nodes, pods, deployments, and service dependencies.</p></article>
            <article class="panel feature"><div class="k-icon">2</div><h3>Auto-Healing Deployments</h3><p>Automatically executes safe restarts and rollout recovery for known failure conditions.</p></article>
            <article class="panel feature"><div class="k-icon">3</div><h3>Instant Slack & Telegram Alerts</h3><p>Pushes actionable incident context directly to the channels your team already uses.</p></article>
            <article class="panel feature"><div class="k-icon">4</div><h3>AI-Powered Root Cause Analysis</h3><p>Correlates events, logs, metrics, and release changes to expose likely failure sources.</p></article>
            <article class="panel feature"><div class="k-icon">5</div><h3>Metrics-Driven Recommendations</h3><p>Identifies resource inefficiencies and recommends targeted workload tuning.</p></article>
            <article class="panel feature"><div class="k-icon">6</div><h3>Predictive Scaling & Optimization</h3><p>Forecasts load pressure and proposes preemptive scaling before incidents occur.</p></article>
          </div>
        </section>

        <section class="section reveal" id="how">
          <h2>How It Works</h2>
          <div class="how-grid">
            <article class="panel how-step"><b>1</b><p>Monitor your cluster continuously with workload and dependency awareness.</p></article>
            <article class="panel how-step"><b>2</b><p>Detect anomalies by combining event streams with resource and rollout telemetry.</p></article>
            <article class="panel how-step"><b>3</b><p>Auto-heal known failure patterns or suggest safe fixes for operator approval.</p></article>
            <article class="panel how-step"><b>4</b><p>Chat with your cluster in real-time and ask direct operational questions.</p></article>
          </div>
        </section>

        <section class="section reveal" id="demo">
          <h2>Interactive Cluster Ops Demo</h2>
          <div class="demo-grid">
            <article class="panel demo-card">
              <h3>Kubernetes Dependency Map</h3>
              <p class="lead" style="font-size: 0.9rem; margin-top: 0.4rem;">Hover a node to inspect metrics and dependency impact in real-time.</p>
              <canvas id="ops-map" aria-label="Pod dependency map"></canvas>
              <canvas id="mini-map" aria-label="Pod health mini-map"></canvas>
              <div class="state-legend">
                <span><i style="background: var(--ok)"></i>Healthy</span>
                <span><i style="background: var(--warn)"></i>Warning</span>
                <span><i style="background: var(--bad)"></i>Error</span>
              </div>
            </article>

            <article class="panel demo-card">
              <h3>Real-time Alerts Timeline</h3>
              <ul id="alerts" class="timeline" aria-live="polite"></ul>

              <div class="metrics">
                <article class="panel metric">
                  <p>CPU Trend</p>
                  <canvas id="cpu-spark" width="300" height="72"></canvas>
                </article>
                <article class="panel metric">
                  <p>Memory Trend</p>
                  <canvas id="mem-spark" width="300" height="72"></canvas>
                </article>
              </div>

              <div class="chat">
                <div class="bubble ask">Why is my pod failing?</div>
                <div class="bubble answer">`payments-api-7bd8` shows high memory pressure and failing probes. Suggested action: increase memory request and add 5s readiness delay.</div>
              </div>
            </article>
          </div>
        </section>

        <section class="section reveal" id="cta">
          <article class="panel cta">
            <h2>Start Building with KubeSolv Today</h2>
            <p>Request early access for guided onboarding and production validation workflows.</p>
            <div class="hero-actions" style="margin-top: 1rem;">
              <button class="btn btn-primary" type="button" id="open-modal-bottom">Want to Know More?</button>
            </div>
          </article>
        </section>
      </main>

      <footer>
        <span>© 2026 KubeSolv</span>
        <div>
          <a href="#">Docs</a>
          <a href="#">GitHub</a>
          <a href="#">Contact</a>
        </div>
      </footer>
    </div>

    <div class="modal" id="lead-modal" aria-hidden="true">
      <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="lead-title">
        <div class="modal-head">
          <h3 id="lead-title">Want to Know More?</h3>
          <button class="close" type="button" id="close-modal" aria-label="Close">×</button>
        </div>
        <p class="lead" style="font-size: 0.9rem; margin-top: 0.45rem;">Share your details and we will follow up with product access details.</p>

        <form id="lead-form">
          <div class="field">
            <label for="lead-name">Name</label>
            <input id="lead-name" name="name" required autocomplete="name" />
          </div>
          <div class="field">
            <label for="lead-email">Email</label>
            <input id="lead-email" name="email" type="email" required autocomplete="email" />
          </div>
          <div class="hero-actions" style="margin-top: 0.9rem;">
            <button class="btn btn-primary" type="submit">Submit</button>
          </div>
          <div id="form-status" class="status"></div>
        </form>
      </div>
    </div>

    <script>
      (function () {
        const reveals = Array.from(document.querySelectorAll('.reveal'));
        const io = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) entry.target.classList.add('in');
          });
        }, { threshold: 0.12 });
        reveals.forEach((el) => io.observe(el));

        const modal = document.getElementById('lead-modal');
        const openModal = () => {
          modal.classList.add('open');
          modal.setAttribute('aria-hidden', 'false');
        };
        const closeModal = () => {
          modal.classList.remove('open');
          modal.setAttribute('aria-hidden', 'true');
        };

        document.getElementById('open-modal').addEventListener('click', openModal);
        document.getElementById('open-modal-bottom').addEventListener('click', openModal);
        document.getElementById('close-modal').addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => {
          if (e.target === modal) closeModal();
        });
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') closeModal();
        });

        const form = document.getElementById('lead-form');
        const status = document.getElementById('form-status');
        form.addEventListener('submit', async (e) => {
          e.preventDefault();
          status.textContent = 'Submitting...';
          const payload = {
            name: form.name.value.trim(),
            email: form.email.value.trim(),
            source: 'kubesolv_landing',
            submittedAt: new Date().toISOString()
          };

          let ok = false;
          try {
            const res = await fetch('/api/kubesolv-leads', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            ok = res.ok;
          } catch (_err) {}

          if (!ok) {
            try {
              await fetch('https://example.com/webhook/kubesolv-leads', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });
              ok = true;
            } catch (_err) {}
          }

          if (!ok) {
            localStorage.setItem('kubesolvLeadDraft', JSON.stringify(payload));
            status.textContent = 'Saved locally. Connect API/webhook to complete submission.';
            return;
          }

          status.textContent = 'Thanks. We received your request.';
          form.reset();
        });

        const signalTokens = {
          detect: document.querySelector('[data-signal="detect"]'),
          notify: document.querySelector('[data-signal="notify"]'),
          heal: document.querySelector('[data-signal="heal"]')
        };
        let tokenResetTimer = null;
        const pulseSignal = (type) => {
          Object.values(signalTokens).forEach((el) => el.classList.remove('alert'));
          if (signalTokens[type]) signalTokens[type].classList.add('alert');
          clearTimeout(tokenResetTimer);
          tokenResetTimer = setTimeout(() => {
            Object.values(signalTokens).forEach((el) => el.classList.remove('alert'));
          }, 1400);
        };

        const statusColor = {
          healthy: getComputedStyle(document.documentElement).getPropertyValue('--ok').trim(),
          warning: getComputedStyle(document.documentElement).getPropertyValue('--warn').trim(),
          error: getComputedStyle(document.documentElement).getPropertyValue('--bad').trim()
        };

        const nodes = [
          { id: 'ingress', label: 'Ingress', role: 'Gateway', status: 'healthy', cpu: 34, mem: 52, restarts: 0, heroX: 0.14, heroY: 0.33, mapX: 0.13, mapY: 0.24, shape: 'hex' },
          { id: 'auth', label: 'Auth API', role: 'Pod', status: 'healthy', cpu: 49, mem: 61, restarts: 1, heroX: 0.36, heroY: 0.28, mapX: 0.33, mapY: 0.26, shape: 'circle' },
          { id: 'billing', label: 'Billing', role: 'Pod', status: 'warning', cpu: 72, mem: 73, restarts: 2, heroX: 0.56, heroY: 0.45, mapX: 0.52, mapY: 0.44, shape: 'circle' },
          { id: 'payments', label: 'Payments', role: 'Pod', status: 'error', cpu: 88, mem: 92, restarts: 5, heroX: 0.76, heroY: 0.3, mapX: 0.72, mapY: 0.32, shape: 'circle' },
          { id: 'worker', label: 'Worker', role: 'Pod', status: 'healthy', cpu: 43, mem: 55, restarts: 0, heroX: 0.79, heroY: 0.63, mapX: 0.81, mapY: 0.58, shape: 'circle' },
          { id: 'redis', label: 'Redis', role: 'Service', status: 'healthy', cpu: 31, mem: 47, restarts: 0, heroX: 0.58, heroY: 0.74, mapX: 0.57, mapY: 0.68, shape: 'hex' },
          { id: 'metrics', label: 'Metrics', role: 'Service', status: 'warning', cpu: 66, mem: 68, restarts: 1, heroX: 0.32, heroY: 0.66, mapX: 0.34, mapY: 0.65, shape: 'hex' }
        ];

        const links = [
          ['ingress', 'auth'],
          ['auth', 'billing'],
          ['billing', 'payments'],
          ['billing', 'worker'],
          ['worker', 'redis'],
          ['metrics', 'auth']
        ];

        const byId = (id) => nodes.find((n) => n.id === id);

        let hoveredId = null;
        const tooltip = document.getElementById('cluster-tooltip');

        const fitCanvas = (canvas) => {
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          const rect = canvas.getBoundingClientRect();
          canvas.width = Math.max(2, Math.floor(rect.width * dpr));
          canvas.height = Math.max(2, Math.floor(rect.height * dpr));
          const ctx = canvas.getContext('2d');
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          return { ctx, w: rect.width, h: rect.height };
        };

        const drawHex = (ctx, x, y, r) => {
          ctx.beginPath();
          for (let i = 0; i < 6; i += 1) {
            const a = (Math.PI / 3) * i - Math.PI / 2;
            const px = x + Math.cos(a) * r;
            const py = y + Math.sin(a) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
        };

        const hitNode = (x, y, w, h, mapKey) => {
          for (let i = nodes.length - 1; i >= 0; i -= 1) {
            const n = nodes[i];
            const nx = n[mapKey + 'X'] * w;
            const ny = n[mapKey + 'Y'] * h;
            const r = 19;
            if (Math.hypot(x - nx, y - ny) <= r + 4) return n;
          }
          return null;
        };

        const drawOpsCluster = (canvas, mapKey) => {
          const fit = fitCanvas(canvas);
          const { ctx, w, h } = fit;

          for (let y = 18; y < h; y += 30) {
            const offset = Math.floor(y / 30) % 2 ? 11 : 0;
            for (let x = 12; x < w; x += 22) {
              ctx.beginPath();
              ctx.arc(x + offset, y, 1.1, 0, Math.PI * 2);
              ctx.fillStyle = 'rgba(83, 123, 214, 0.14)';
              ctx.fill();
            }
          }

          links.forEach(([a, b]) => {
            const na = byId(a);
            const nb = byId(b);
            const x1 = na[mapKey + 'X'] * w;
            const y1 = na[mapKey + 'Y'] * h;
            const x2 = nb[mapKey + 'X'] * w;
            const y2 = nb[mapKey + 'Y'] * h;
            const active = hoveredId && (hoveredId === a || hoveredId === b);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = active ? 'rgba(70, 125, 255, 0.62)' : 'rgba(70, 125, 255, 0.26)';
            ctx.lineWidth = active ? 2 : 1.2;
            ctx.stroke();
          });

          nodes.forEach((n, i) => {
            const x = n[mapKey + 'X'] * w;
            const y = n[mapKey + 'Y'] * h;
            const glow = Math.sin(Date.now() / 420 + i) * 1.5;
            const stateR = n.status === 'error' ? 15 : n.status === 'warning' ? 14 : 13;
            const r = stateR + glow;
            const color = statusColor[n.status];
            const active = hoveredId === n.id;

            ctx.beginPath();
            ctx.arc(x, y, r + (active ? 4 : 2), 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${n.status === 'error' ? '238,95,114' : n.status === 'warning' ? '241,184,70' : '30,189,122'}, ${active ? 0.24 : 0.14})`;
            ctx.fill();

            if (n.shape === 'hex') {
              drawHex(ctx, x, y, r);
              ctx.fillStyle = color;
              ctx.fill();
              ctx.strokeStyle = 'rgba(255,255,255,0.75)';
              ctx.lineWidth = 1;
              ctx.stroke();
            } else {
              ctx.beginPath();
              ctx.arc(x, y, r, 0, Math.PI * 2);
              ctx.fillStyle = color;
              ctx.fill();
              ctx.strokeStyle = 'rgba(255,255,255,0.72)';
              ctx.lineWidth = 1;
              ctx.stroke();
            }

            const labelSize = mapKey === 'hero' ? 10 : 9;
            ctx.fillStyle = '#2b3f71';
            ctx.font = `600 ${labelSize}px Inter, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(n.label, x, y + r + 14);
          });

          return { w, h };
        };

        const drawHeroCluster = (canvas) => {
          const fit = fitCanvas(canvas);
          const { ctx, w, h } = fit;
          const cx = w * 0.52;
          const cy = h * 0.5;

          ctx.clearRect(0, 0, w, h);

          for (let i = 0; i < 3; i += 1) {
            const r = 54 + i * 28;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(90, 136, 255, ${0.18 - i * 0.04})`;
            ctx.lineWidth = 1.1;
            ctx.stroke();
          }

          const lanes = [
            [0.14, 0.28, cx, cy],
            [0.28, 0.14, cx, cy],
            [0.79, 0.2, cx, cy],
            [0.86, 0.56, cx, cy],
            [0.64, 0.84, cx, cy],
            [0.2, 0.74, cx, cy]
          ];
          lanes.forEach(([sxr, syr, ex, ey]) => {
            const sx = sxr * w;
            const sy = syr * h;
            const grad = ctx.createLinearGradient(sx, sy, ex, ey);
            grad.addColorStop(0, 'rgba(63, 110, 255, 0)');
            grad.addColorStop(0.55, 'rgba(63, 110, 255, 0.36)');
            grad.addColorStop(1, 'rgba(22, 198, 211, 0.42)');
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(ex, ey);
            ctx.strokeStyle = grad;
            ctx.lineWidth = 1.7;
            ctx.stroke();
          });

          const pulse = Math.sin(Date.now() / 620) * 4;
          ctx.beginPath();
          ctx.arc(cx, cy, 42 + pulse, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(22, 198, 211, 0.18)';
          ctx.fill();

          ctx.beginPath();
          ctx.arc(cx, cy, 34, 0, Math.PI * 2);
          ctx.fillStyle = '#16c6d3';
          ctx.fill();
          ctx.strokeStyle = 'rgba(255,255,255,0.75)';
          ctx.lineWidth = 1.2;
          ctx.stroke();

          ctx.fillStyle = '#ffffff';
          ctx.font = '700 12px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('AI SRE', cx, cy);

          nodes.forEach((n, i) => {
            const x = n.heroX * w;
            const y = n.heroY * h;
            const active = hoveredId === n.id;
            const glow = Math.sin(Date.now() / 520 + i) * 1.2;
            const stateR = n.status === 'error' ? 14 : n.status === 'warning' ? 13 : 12;
            const r = stateR + glow;
            const color = statusColor[n.status];

            if (n.shape === 'hex') {
              drawHex(ctx, x, y, r + (active ? 2.8 : 0));
              ctx.fillStyle = color;
              ctx.fill();
              ctx.strokeStyle = active ? 'rgba(255,255,255,0.86)' : 'rgba(255,255,255,0.58)';
              ctx.lineWidth = 1;
              ctx.stroke();
            } else {
              ctx.beginPath();
              ctx.arc(x, y, r + (active ? 2.8 : 0), 0, Math.PI * 2);
              ctx.fillStyle = color;
              ctx.fill();
              ctx.strokeStyle = active ? 'rgba(255,255,255,0.86)' : 'rgba(255,255,255,0.58)';
              ctx.lineWidth = 1;
              ctx.stroke();
            }

            ctx.fillStyle = '#243a70';
            ctx.font = '600 9px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(n.label, x, y + r + 12);
          });
        };

        const heroCanvas = document.getElementById('hero-map');
        const opsCanvas = document.getElementById('ops-map');
        const miniCanvas = document.getElementById('mini-map');

        const onHeroMove = (event) => {
          const rect = heroCanvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          const hit = hitNode(x, y, rect.width, rect.height, 'hero');
          hoveredId = hit ? hit.id : null;

          if (!hit) {
            tooltip.classList.remove('show');
            return;
          }

          tooltip.classList.add('show');
          tooltip.style.left = `${Math.min(rect.width - 190, Math.max(8, x + 12))}px`;
          tooltip.style.top = `${Math.max(10, y - 68)}px`;
          tooltip.innerHTML = `<strong>${hit.label}</strong>CPU: ${hit.cpu}%<br />Memory: ${hit.mem}%<br />Restarts: ${hit.restarts}`;
        };

        heroCanvas.addEventListener('mousemove', onHeroMove);
        heroCanvas.addEventListener('mouseleave', () => {
          hoveredId = null;
          tooltip.classList.remove('show');
        });

        const alertFeed = document.getElementById('alerts');
        const eventsPool = [
          { text: 'OOMKilled on payments pod', level: 'error', signal: 'detect', target: 'payments' },
          { text: 'ImagePullBackOff on billing worker', level: 'warning', signal: 'detect', target: 'billing' },
          { text: 'Alert pushed to Slack + Telegram', level: 'warning', signal: 'notify', target: 'metrics' },
          { text: 'Auto-heal restart completed for auth pod', level: 'healthy', signal: 'heal', target: 'auth' },
          { text: 'Scaling recommendation generated for worker', level: 'healthy', signal: 'notify', target: 'worker' }
        ];

        const addAlert = (eventItem) => {
          const li = document.createElement('li');
          li.innerHTML = `<span class="t-dot" style="background:${statusColor[eventItem.level] || statusColor.warning}"></span><span>${eventItem.text}</span>`;
          alertFeed.prepend(li);
          while (alertFeed.children.length > 6) alertFeed.removeChild(alertFeed.lastChild);
          pulseSignal(eventItem.signal);
          hoveredId = eventItem.target;
          setTimeout(() => {
            if (hoveredId === eventItem.target) hoveredId = null;
          }, 1300);
        };

        addAlert({ text: 'Initial scan complete for production namespace', level: 'healthy', signal: 'detect', target: 'ingress' });
        addAlert({ text: 'Warning: memory pressure in billing pod', level: 'warning', signal: 'notify', target: 'billing' });

        const randomizeNodeState = () => {
          const idx = Math.floor(Math.random() * nodes.length);
          const states = ['healthy', 'warning', 'error'];
          const n = nodes[idx];
          n.status = states[Math.floor(Math.random() * states.length)];
          n.cpu = Math.max(28, Math.min(96, n.cpu + Math.floor(Math.random() * 21) - 10));
          n.mem = Math.max(24, Math.min(98, n.mem + Math.floor(Math.random() * 18) - 8));
          n.restarts = Math.max(0, Math.min(8, n.restarts + Math.floor(Math.random() * 3) - 1));
        };

        setInterval(() => {
          randomizeNodeState();
          const e = eventsPool[Math.floor(Math.random() * eventsPool.length)];
          addAlert(e);
        }, 2500);

        const cpuSpark = document.getElementById('cpu-spark');
        const memSpark = document.getElementById('mem-spark');
        let cpuSeries = [52, 58, 62, 56, 68, 64, 71, 66, 69];
        let memSeries = [48, 50, 47, 55, 57, 62, 60, 64, 63];

        const drawSpark = (canvas, arr, color) => {
          const ctx = canvas.getContext('2d');
          const w = canvas.width;
          const h = canvas.height;
          ctx.clearRect(0, 0, w, h);
          ctx.beginPath();
          arr.forEach((v, i) => {
            const x = (i / (arr.length - 1)) * (w - 8) + 4;
            const y = h - ((v - 10) / 100) * (h - 12) - 6;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          });
          ctx.strokeStyle = color;
          ctx.lineWidth = 3;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.stroke();
        };

        const tickSpark = () => {
          cpuSeries = cpuSeries.slice(1).concat(Math.max(30, Math.min(90, cpuSeries[cpuSeries.length - 1] + (Math.random() * 16 - 8))));
          memSeries = memSeries.slice(1).concat(Math.max(28, Math.min(88, memSeries[memSeries.length - 1] + (Math.random() * 14 - 7))));
          drawSpark(cpuSpark, cpuSeries, '#3f6eff');
          drawSpark(memSpark, memSeries, '#16c6d3');
        };

        tickSpark();
        setInterval(tickSpark, 1700);

        const bgCanvas = document.getElementById('bg-canvas');
        const bgCtx = bgCanvas.getContext('2d');
        const bgNodes = [];
        const BG_COUNT = 44;

        const resizeBg = () => {
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          bgCanvas.width = Math.floor(window.innerWidth * dpr);
          bgCanvas.height = Math.floor(window.innerHeight * dpr);
          bgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
          if (!bgNodes.length) {
            for (let i = 0; i < BG_COUNT; i += 1) {
              bgNodes.push({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                vx: (Math.random() - 0.5) * 0.26,
                vy: (Math.random() - 0.5) * 0.26,
                r: Math.random() * 1.6 + 0.7
              });
            }
          }
        };

        const tickBg = () => {
          const w = window.innerWidth;
          const h = window.innerHeight;
          bgCtx.clearRect(0, 0, w, h);

          bgNodes.forEach((n) => {
            n.x += n.vx;
            n.y += n.vy;
            if (n.x < -7) n.x = w + 7;
            if (n.x > w + 7) n.x = -7;
            if (n.y < -7) n.y = h + 7;
            if (n.y > h + 7) n.y = -7;
            bgCtx.beginPath();
            bgCtx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
            bgCtx.fillStyle = 'rgba(85, 126, 220, 0.16)';
            bgCtx.fill();
          });

          for (let i = 0; i < bgNodes.length; i += 1) {
            for (let j = i + 1; j < bgNodes.length; j += 1) {
              const a = bgNodes[i];
              const b = bgNodes[j];
              const d = Math.hypot(a.x - b.x, a.y - b.y);
              if (d < 120) {
                const alpha = (1 - d / 120) * 0.08;
                bgCtx.beginPath();
                bgCtx.moveTo(a.x, a.y);
                bgCtx.lineTo(b.x, b.y);
                bgCtx.strokeStyle = `rgba(63,110,255,${alpha})`;
                bgCtx.stroke();
              }
            }
          }

          requestAnimationFrame(tickBg);
        };

        const render = () => {
          drawHeroCluster(heroCanvas);
          drawOpsCluster(opsCanvas, 'map');
          drawOpsCluster(miniCanvas, 'map');
          requestAnimationFrame(render);
        };

        const resizeAll = () => {
          fitCanvas(heroCanvas);
          fitCanvas(opsCanvas);
          fitCanvas(miniCanvas);
          resizeBg();
        };

        window.addEventListener('resize', resizeAll);
        resizeAll();
        tickBg();
        render();
      })();
    </script>
  </body>
</html>
